# Отчет по лабораторным

## ex1

Программа создает и запускает процессы с функцией `worker`   
`Worker`: печатает в терминал текст 'Worker'

`__main__`:

1. Выводит доступное количество процессов
2. Инициализирует слайс `jobs`
3. Итерируемся по числам 0-4
    1. Создаем объект процесса с функцией `worker`
    2. Добавляем объект в слайс `jobs`
    3. Запускаем процесс
    4. Ждем завершения процесса
4. Печатаем информацию об объектах процессов в слайсе `jobs`

<details>

<summary>Код</summary>

```python
import multiprocessing


def worker():
    """worker function,
    печатает текст Worker
    """


print('Worker')

return

if __name__ == '__main__':

# Выводит доступное количество процессов

print('Threads available: ', multiprocessing.cpu_count())
jobs = []

# Создаем пять процессов, которые печатают Worker
for i in range(5):
    p = multiprocessing.Process(target=worker)

    jobs.append(p)

    p.start()
    p.join()
# Печатает информацию о всех процессах
print(jobs)

```

</details>

## ex1_getpid

Cкрипт создает новый процесс, в котором выполняется функция f('bob'), и основной процесс ожидает, пока
этот процесс завершится. В результате на экран выводится информация о каждом процессе и строка 'hello bob'.

1. Определяется функция `info(title)`, которая выводит информацию о процессе, такую как название, имя модуля,
   идентификатор родительского процесса и идентификатор текущего процесса.

2. Определяется функция `f(name)`, которая просто вызывает функцию `info('function f')` и выводит строку `hello` с
   переданным аргументом name.

3. Выводится информация о процессе основной программы с помощью вызова функции `info('main line')`.

4. Создается новый процесс `p` с целевой функцией `f` и аргументом 'bob'.

5. Запускается процесс p с помощью метода `start()`.

6. Основной процесс ожидает завершения процесса p с помощью метода `join()`.

<details>

<summary>Код</summary>

```python
import os
from multiprocessing import Process


# info
def info(title):
    """
    Печатает title, id родительского процесса, id процесса
    """
    print(title)
    print('module name:', __name__)
    print('parent process:', os.getppid())
    print('process id:', os.getpid())


def f(name):
    """
    Печатает function f и hello + переданный name
    """
    info('function f')
    print('hello', name)


if __name__ == '__main__':
    info('main line')  # Выводится информация по main
    p = Process(target=f, args=('bob',))  # Создается новый процесс, с заданной функцией f с аргументом bob
    p.start()  # Запустить процесс
    p.join()  # Ждем выполнение процесса p

```

</details>

## ex2

1. Определяется функция `worker(num)`, которая принимает аргумент num и просто выводит сообщение вида "Worker: num". Это
   будет функция, которая будет выполняться в каждом создаваемом процессе.

2. Создается пустой список `jobs`, который будет содержать объекты процессов.

3. Запускается цикл for, который проходит по диапазону от 0 до 4 (включительно) - всего 5 итераций.

4. В каждой итерации создается новый процесс p с целевой функцией worker и аргументом i, который является текущим
   значением итерации.

5. Созданный процесс добавляется в список `jobs` с помощью метода `append()`.

6. Процесс запускается с помощью метода `start()`.

<details>

<summary>Код</summary>

```python
import multiprocessing


def worker(num):
    """thread worker function"""
    print('Worker:', num)
    return


if __name__ == '__main__':
    # последотельно запускает 5 процессов, которые печают Worker с указанием индекса итерации
    # для чего тут jobs - не ясно
    jobs = []
    for i in range(5):
        p = multiprocessing.Process(target=worker, args=(i,))
        jobs.append(p)
        p.start()

```

</details>

## ex3

1. Создается пустой список `jobs`, который будет содержать объекты процессов.
2. Запускается цикл for, который проходит по диапазону от 0 до 4 (включительно) - всего 5 итераций.
3. В каждой итерации создается новый процесс `p` с целевой функцией, которая устанавливается на `worker` из модуля
   `multiprocessing_import_worker`.
4. Созданный процесс добавляется в список `jobs` с помощью метода `append()`.
5. Процесс запускается с помощью метода `start()`.

<details>

<summary>Код</summary>

```python
import multiprocessing

import multiprocessing_import_worker

if __name__ == '__main__':
    # последотельно запускает 5 процессов, которые вызывают worker из пакета multiprocessing_import_worker
    # печатают Worker с указанием индекса итерации
    # для чего тут jobs - не ясно
    jobs = []
    for i in range(5):
        p = multiprocessing.Process(target=multiprocessing_import_worker.worker)
        jobs.append(p)
        p.start()


```

</details>

## ex4

1. Определяются две функции: `worker()` и `my_service()`, каждая из которых выполняет некоторую работу и выводит время
   начала и завершения выполнения, а также имя процесса.

2. Создаются три процесса с использованием `multiprocessing.Process()`: `my_service`, `worker 1` и `worker 2`. Процессу
   `my_service` и `worker_1` явно задается имя с помощью аргумента name, а `worker_2` получают имена по умолчанию.

3. Запускаются все три процесса с помощью метода `start()`. Каждый процесс начинает выполнение своей соответствующей
   функции.

<details>

<summary>Код</summary>

```python
import multiprocessing
import time


def worker():
    """
        Функция печатает время старта, ждет 2 секунды и печатает время завершения с указанием имени процесса
    """
    name = multiprocessing.current_process().name
    print(name, 'Starting', time.time())  # печатаем имя процесса и время
    time.sleep(2)  # ждем 2 секунды
    print(name, 'Exiting', time.time())  # печатаем имя процесса и время


def my_service():
    """
    Функция печатает время старта, ждет 3 секунды и печатает время завершения с указанием имени процесса
    """
    name = multiprocessing.current_process().name
    print(name, 'Starting', time.time())  # печатаем имя процесса и время
    time.sleep(3)  # ждем 3 секунды
    print(name, 'Exiting', time.time())  # печатаем имя процесса и время


if __name__ == '__main__':
    service = multiprocessing.Process(name='my_service',
                                      target=my_service)  # инициализируем процесс с именем my_service с вызываемой функцией my_service
    worker_1 = multiprocessing.Process(name='worker 1',
                                       target=worker)  # инициализируем процесс с именем worker 1 с вызываемой функцией worker
    worker_2 = multiprocessing.Process(target=worker)  # инициализируем процесс с вызываемой функцией worker

    worker_1.start()  # запускаем процесс worker_1
    worker_2.start()  # запускаем процесс worker_2
    service.start()  # запускаем процесс service

```

</details>

## ex5

1. Определяются две функции: `daemon()` и `non_daemon()`, каждая из которых просто выводит информацию о текущем
   процессе (
   имя и идентификатор) с использованием `multiprocessing.current_process()`. Функция `daemon()` также задерживается на
   2
   секунды.

2. Создаются два процесса с использованием `multiprocessing.Process()`: d (демонический) и n (недемонический). Каждый из
   них получает имя и целевую функцию для выполнения.

3. Устанавливаются признаки демонического процесса (`daemon`) для каждого процесса: d установлен в `True`, а n -
   в `False`.

4. Запускается процесс `d` (демонический), а затем делается пауза на 1 секунду.

5. Запускается процесс `n` (недемонический).

Таким образом, демонический процесс `d` запускается первым, но из-за своего признака демона он не будет дожидаться
завершения основного процесса, и поэтому не будет завершен до конца. В то время как недемонический процесс n, запущенный
вторым, будет выполняться полностью, так как он не зависит от основного процесса.

<details>

<summary>Код</summary>

```python
import multiprocessing
import sys
import time


def daemon():
    p = multiprocessing.current_process()
    print('Starting:', p.name, p.pid)  # печатаем имя процесса и идентификатор процесса
    sys.stdout.flush()  # принудительно очищаем буфер вывода
    time.sleep(2)  # ждем 2 секунды
    print('Exiting :', p.name, p.pid)  # печатаем имя процесса и идентификатор процесса
    sys.stdout.flush()  # принудительно очищаем буфер вывода


def non_daemon():
    p = multiprocessing.current_process()
    print('Starting:', p.name, p.pid)  # печатаем имя процесса и идентификатор процесса
    sys.stdout.flush()  # принудительно очищаем буфер вывода
    print('Exiting :', p.name, p.pid)  # печатаем имя процесса и идентификатор процесса
    sys.stdout.flush()  # принудительно очищаем буфер вывода


# Скрипт запускает демонический и недемонический процесс. Демонический процесс не успеет до конца отработать,
# так как демонические процессы завершаются, когда основной процесс (главный процесс) завершается
if __name__ == '__main__':
    d = multiprocessing.Process(name='daemon', target=daemon)  # процесс демон, с вызываемой функцией daemon
    d.daemon = True  # признак daemon поставлен в true

    n = multiprocessing.Process(name='non-daemon',
                                target=non_daemon)  # процесс недемон, с вызываемой функцией non-daemon
    n.daemon = False  # признак daemon поставлен в false

    d.start()  # запускаем процесс daemon
    time.sleep(1)  # ждем секунду
    n.start()  # запускаем процесс non-daemon


```

</details>

## ex6

1. Определяются две функции: `daemon()` и `non_daemon()`, каждая из которых просто выводит информацию о текущем
   процессе (имя и время).

2. Создаются два процесса с использованием `multiprocessing.Process()`: `d` (демонический) и `n` (недемонический).
   Каждый из них получает имя и целевую функцию для выполнения.

3. Устанавливаются признаки демонического процесса (`daemon`) для каждого процесса: `d` установлен в `True`, а `n` -
   в `False`.

4. Запускается процесс `d` (демонический), а затем делается пауза на 1 секунду.

5. Запускается процесс `n` (недемонический).

6. Выполняются методы `join()` для обоих процессов, чтобы дождаться их завершения.

7. Печатается время завершения основного процесса.

Таким образом, оба процесса `d` и `n` выполняются и завершаются, и основной процесс ожидает их завершения, прежде чем
завершиться сам.

<details>

<summary>Код</summary>

```python
import multiprocessing
import time


def daemon():
    print('Starting:', multiprocessing.current_process().name, time.time())  # печатаем имя процесса и время
    time.sleep(2)  # ждем 2 секунды
    print('Exiting :', multiprocessing.current_process().name, time.time())  # печатаем имя процесса и время


def non_daemon():
    print('Starting:', multiprocessing.current_process().name, time.time())  # печатаем имя процесса и время
    print('Exiting :', multiprocessing.current_process().name, time.time())  # печатаем имя процесса и время


# Скрипт запускает демонический и недемонический процесс.
# Оба процесса отработают (daemon/non-daemon), т.к. есть ожидание процессов
if __name__ == '__main__':
    d = multiprocessing.Process(name='daemon', target=daemon)  # процесс демон, с вызываемой функцией daemon
    d.daemon = True  # признак daemon поставлен в true

    n = multiprocessing.Process(name='non-daemon',
                                target=non_daemon)  # процесс недемон, с вызываемой функцией non-daemon
    n.daemon = False  # признак daemon поставлен в false

    d.start()  # запускаем процесс daemon
    time.sleep(1)  # ждем секунду
    n.start()  # запускаем процесс non-daemon

    d.join()  # ждем выполнения процесса daemon
    n.join()  # ждем выполнения процесса non-daemon
    print('End main ', time.time())  # печатаем время завершения основного процесса

```

</details>

## ex7

1. Определяются две функции: `daemon()` и `non_daemon()`, каждая из которых просто выводит информацию о текущем
   процессе (имя и время), а затем ждет некоторое время.

2. Создаются два процесса с использованием `multiprocessing.Process()`: `d` (демонический) и `n` (недемонический).
   Каждый из них получает имя и целевую функцию для выполнения.

3. Устанавливаются признаки демонического процесса (`daemon`) для каждого процесса: `d` установлен в `True`, а `n` -
   в `False`.

4. Запускается процесс `d` (демонический) и процесс `n` (недемонический).

5. Выполняется метод `join(1)` для процесса `d`, что означает, что основной процесс будет ожидать его завершения в
   течение 1 секунды. Выводится значение `d.is_alive()`, которое показывает, жив ли процесс `d` (что вернет `True`, так
   как функция демона еще не завершилась, а ждали выполнение процесса только 1 секунду).

6. Выполняется метод `join()` для процесса `n`, чтобы дождаться его завершения.

7. Печатается время завершения основного процесса.

<details>

<summary>Код</summary>

```python
import multiprocessing
import time


def daemon():
    print('Starting:', multiprocessing.current_process().name, time.time())  # печатаем имя процесса и время
    time.sleep(2)  # ждем 2 секунды
    print('Exiting :', multiprocessing.current_process().name, time.time())  # печатаем имя процесса и время


def non_daemon():
    print('Starting:', multiprocessing.current_process().name, time.time())  # печатаем имя процесса и время
    print('Exiting :', multiprocessing.current_process().name, time.time())  # печатаем имя процесса и время


if __name__ == '__main__':
    d = multiprocessing.Process(name='daemon', target=daemon)  # процесс демон, с вызываемой функцией daemon
    d.daemon = True  # признак daemon поставлен в true

    n = multiprocessing.Process(name='non-daemon',
                                target=non_daemon)  # процесс недемон, с вызываемой функцией non-daemon
    n.daemon = False  # признак daemon поставлен в false

    d.start()  # запускаем процесс daemon
    n.start()  # запускаем процесс non-daemon

    d.join(1)  # ждем выполнения процесса daemon с указанием таймаута в 1 секунду, после чего продолжается программа
    print('d.is_alive()', d.is_alive(),
          time.time())  # выводим значение d.is_alive с указанием времени
    # (вернется тру, тк функция демона еще не закончится, а ждали выполнение процесса только 1 сек)
    n.join()  # ждем выполнения процесса non-daemon
    print('End main ', time.time())  # печатаем время завершения основного процесса

```

</details>

## ex8

1. Определяется функция `slow_worker()`, которая просто выводит информацию о времени начала и завершения работы.

2. Создается объект процесса `p` с вызываемой функцией `slow_worker()` в качестве целевой.

3. Выводится информация о процессе до его запуска, включая его текущее состояние `is_alive()` (которое должно
   быть `False`, так как
   процесс еще не запущен).

4. Запускается процесс с помощью метода `start()`.

5. Выводится информация о процессе во время его выполнения, включая его текущее состояние (которое должно быть `True`,
   так как процесс запущен и работает).

6. Вызывается метод `terminate()`, чтобы отправить сигнал об уничтожении процесса.

7. Выводится информация о процессе после его завершения, включая его текущее состояние (которое все еще должно
   быть `True`, так как процесс не завершился).

8. Вызывается метод `join()`, чтобы дождаться завершения работы процесса.

9. Выводится информация о процессе после его завершения, включая его текущее состояние (которое должно быть `False`,
   так как процесс завершился).

<details>

<summary>Код</summary>

```python
import multiprocessing
import time


def slow_worker():
    print('Starting worker', time.time())  # печатаем время начала slow_worker
    time.sleep(0.1)  # ждем 0.1 секунды
    print('Finished worker', time.time())  # печатаем время завершения slow_worker


# создается процесс, после выводится информация о состоянии процесса после различных манипуляций
if __name__ == '__main__':
    p = multiprocessing.Process(target=slow_worker)  # инициализируем процесс с вызываемой функцией slow_worker
    print('BEFORE:', p, p.is_alive(),
          time.time())  # печатаем информацию о процессе и его текущее состояние is_alive() (false)

    p.start()  # запускаем процесс
    print('DURING:', p, p.is_alive(), time.time())  # печатаем состояние процесса is_alive() (true)

    p.terminate()  # отправляем сигнал об уничтожении процесса (функция slow_worker ничего не успеет сделать!)
    print('TERMINATED:', p, p.is_alive(), time.time())  # печатаем состояние процесса is_alive() (true)

    p.join()  # ждем отработки процесса
    print('JOINED:', p, p.is_alive(), time.time())  # печатаем состояние процесса is_alive() (false)


```

</details>

## ex10

1. Определяется функция `worker()`, которая просто выводит сообщение "Doing some work" в стандартный поток вывода.

2. Вызывается функция `multiprocessing.log_to_stderr(logging.DEBUG)`, которая настраивает логирование для
   модуля `multiprocessing` с уровнем `DEBUG`, что означает вывод всех сообщений лога.

3. Создается процесс `p` с целевой функцией `worker()`.

4. Запускается процесс `p` с помощью метода `start()`.

5. Основной процесс ожидает завершения работы процесса `p` с помощью метода `join()`.

<details>

<summary>Код</summary>

```python
import logging
import multiprocessing
import sys


def worker():
    print('Doing some work')  # печатает текст
    sys.stdout.flush()  # принудительно очищаем буфер вывода


if __name__ == '__main__':
    multiprocessing.log_to_stderr(
        logging.DEBUG)  # создает логер с выводом в терминал с уровнем DEBUG (вывод логов всех уровней)
    p = multiprocessing.Process(target=worker)  # инициализируем процесс с вызываемой функцией worker
    p.start()  # запускает процесс р
    p.join()  # ждем выполнения процесса р

```

</details>

## ex11

1. Определяется функция `worker()`, которая просто выводит сообщение "Doing some work" и
   принудительно очищает буфер вывода.

2. Вызывается функция `multiprocessing.log_to_stderr()`, которая настраивает вывод логов для модуля `multiprocessing` в
   стандартный поток ошибок (`stderr`).

3. Получается объект логгера с помощью функции `multiprocessing.get_logger()`.

4. Устанавливается уровень логирования для полученного логгера на `INFO`.

5. Создается процесс `p` с целевой функцией `worker()`.

6. Запускается процесс `p` с помощью метода `start()`.

7. Основной процесс ожидает завершения работы процесса `p` с помощью метода `join()`.

<details>

<summary>Код</summary>

```python
import logging
import multiprocessing
import sys


def worker():
    print('Doing some work')  # печатает текст
    sys.stdout.flush()  # принудительно очищаем буфер вывода


if __name__ == '__main__':
    multiprocessing.log_to_stderr()  # устанавливаем вывод логов в терминал
    logger = multiprocessing.get_logger()  # получем логгер
    logger.setLevel(logging.INFO)  # устанавливаем для логгера уровень INFO
    p = multiprocessing.Process(target=worker)  # инициализируем процесс с вызываемой функцией worker
    p.start()  # запускает процесс р
    p.join()  # ждем выполнения процесса р


```

</details>

## ex12

1. Определяется класс `Worker`, который наследует класс `multiprocessing.Process`.

2. Внутри класса `Worker` определен метод `run()`, который выводит сообщение о том, в каком процессе он выполняется,
   используя атрибут `self.name`.

3. Создается пустой список `jobs`, куда будут добавлены все процессы `Worker`.

4. В цикле `for` создается 5 экземпляров класса `Worker`, каждый из которых добавляется в список `jobs` и запускается
   методом `start()`.

5. Затем происходит ожидание завершения всех процессов, вызывая метод `join()` для каждого процесса в списке `jobs`.

<details>

<summary>Код</summary>

```python
import multiprocessing


# Класс Worker, который наследует класс Process
class Worker(multiprocessing.Process):

    # Переопределяем процеес run, который выводит сообщение о том, в каком процессе он выполняется
    def run(self):
        print('In %s' % self.name)
        return


if __name__ == '__main__':
    # Создаем список jobs, куда будем добавлять Worker
    jobs = []

    # Создаем 5 экземпляров класса Worker, добавляем их в список jobs и запускаем каждый процесс
    for i in range(5):
        p = Worker()  # инициализируем Worker
        jobs.append(p)  # добавляем всех воркера в jobs
        p.start()  # запускаем процесс

    for j in jobs:
        j.join()  # ждем завершения всех воркеров

```

</details>

## ex_lock

1. Определяется функция `f(lock, i)`, которая выполняет следующие действия:
    * Захватывает блокировку, вызывая метод `acquire()` для объекта `lock`.
    * Печатает сообщение "hello world" с указанием значения индекса `i`.
    * Освобождает блокировку, вызывая метод `release()` для объекта `lock`.

2. Создается объект блокировки `lock` с помощью конструктора `Lock()`.

3. В цикле `for` создается и запускается 10 процессов, каждый из которых имеет целевую функцию `f()` с
   аргументами `lock` и `num` (индекс). Каждый процесс запускается методом `start()`.

Таким образом, скрипт создает и запускает 10 параллельных процессов, которые блокируют и освобождают общую блокировку,
печатая сообщение "hello world" с соответствующим индексом. Использование блокировки `Lock` гарантирует, что только один
процесс может в каждый момент времени иметь доступ к ресурсу, в данном случае к стандартному выводу.

<details>

<summary>Код</summary>

```python
from multiprocessing import Process, Lock


def f(lос, i):
    lос.acquire()  # блокируем локер
    print('hello world', i)  # печатаем hello world c указанием индекса
    lос.release()  # высвобождаем локер


if __name__ == '__main__':
    # создаем локер
    lock = Lock()

    # Создаем и запускаем 10 процессов с целевой функией f с агрументами локером и индексом
    for num in range(10):
        Process(target=f, args=(lock, num)).start()


```

</details>

## ex_pipe

1. Определяется функция `pipe_func(ch, N_iter)`, которая принимает два аргумента: канал `ch` и количество
   итераций `N_iter`. В этой функции выполняются следующие действия:

    * Цикл `for` проходит по диапазону от 0 до `N_iter - 1`.
    * На каждой итерации значение переменной `a` увеличивается на 1, затем это значение отправляется в канал `ch`.
    * После завершения цикла в канал `ch` отправляется строка `'STOP'`, чтобы указать, что все итерации завершены.

2. Создается канал между родительским и дочерним процессами с помощью метода `multiprocessing.Pipe()`. Этот метод
   возвращает пару объектов канала: один для чтения (`parent`) и один для записи (`child`).

3. В цикле `for` счетчик идет от 0 до 3, создается и запускается процесс с целевой функцией `pipe_func()`, передавая в
   нее объект канала `child` и текущее значение счетчика `iter`.

4. Внутри цикла `while` происходит чтение данных из канала `parent`, и печать номера итерации и полученного результата
   до тех пор, пока не будет принято сообщение `'STOP'`.

<details>

<summary>Код</summary>

```python
import multiprocessing


def pipe_func(ch, N_iter):
    a = 0
    # отправояем в канал поочередно значения от 0 до номера итерации
    for i in range(N_iter):
        a += 1
        ch.send(a)

    # отправляем в канал СТОП
    ch.send('STOP')


if __name__ == '__main__':
    # Создаем канал между родительским и дочерним процессами
    parent, child = multiprocessing.Pipe()

    for iter in range(4):
        # создаем процесс с целевой функцией pipe_func, передаем аргумент канал и текущую итерацию
        p = multiprocessing.Process(target=pipe_func, args=(child, iter))
        p.start()  # запускаем процесс р

        result = None
        # пока не получим из канала СТОП, печатаем в терминал номер итерации и результат
        # из канала от функции pipe_func
        while result != 'STOP':
            result = parent.recv()
            print(iter, result)

```

</details>

## ex_Pool_1

1. Определяется функция `f(x)`, которая возвращает квадрат переданного числа `x`.

2. Создается объект пула процессов `p` с помощью конструктора `Pool(5)`, указывая количество процессов равным 5.

3. Вызывается метод `map()` объекта пула `p`, который параллельно применяет функцию `f()` ко всем элементам
   списка `[1, 2, 3]`. Результаты вычислений возвращаются как список.

4. Полученный список результатов выводится на экран с помощью функции `print()`.

<details>

<summary>Код</summary>

```python
from multiprocessing import Pool


# функция возвращает квадрат переданного числа
def f(x):
    return x * x


if __name__ == '__main__':
    # создается объект пула из 5 процессов
    p = Pool(5)
    # параллельно вызывается функция f для значений из списка, потом полученных результат печатается
    print(p.map(f, [1, 2, 3]))

```

</details>

## ex_Pool_time_check

1. Определяется функция `some_slow_calc(x)`, которая проводит некие вычисления над переданным аргументом `x` в цикле 100
   раз, а затем возвращает результат конечной итерации.

2. В блоке `if __name__ == '__main__':`:

    * Засекается время начала последовательных вычислений.
    * Выполняется цикл от 0 до 99999, где для каждого значения `x` вызывается функция `some_slow_calc(x)`.
    * Засекается время окончания последовательных вычислений и выводится на экран время,
      затраченное на последовательные вычисления.
3. Далее скрипт проходит циклом по значениям `n` от 1 до 4:

    * Засекается время начала параллельных вычислений для `n` процессов.
    * Создается объект пула процессов `p` с указанием количества процессов `n`.
    * При помощи метода `map()` пула `p` параллельно вызывается функция `some_slow_calc()` для значений от 0 до 99999.
    * Засекается время окончания параллельных вычислений и выводится на экран время,
      затраченное на параллельные вычисления для `n` процессов.

<details>

<summary>Код</summary>

```python
from math import sin, cos
from multiprocessing import Pool
from time import time


# Функция, которая проводит некие вычисления над переданным аргументом 100 раз,
# результат конечной итерации возвращается
def some_slow_calc(x):
    for i in range(100):
        y = sin(cos(sin(cos(x + i))))
    return y


if __name__ == '__main__':
    # засекается время вычислений последовательного вычисления
    t_start = time()
    for x in range(100000):
        z = some_slow_calc(x)
    t_end = time()
    print('time of non parallel version', t_end - t_start)

    # засекается время вычисления для n-пульных процессов
    for n in [1, 2, 3, 4]:
        t_start = time()
        # создается объект пула из процессов
        p = Pool(processes=n)
        # параллельно вызывается функция some_slow_calc для 0-99999
        p.map(some_slow_calc, [x for x in range(100000)])
        t_end = time()
        print('time of parallel calc on', n, 'proc', t_end - t_start)

```

</details>

## ex_queue

1. Из модуля `multiprocessing` импортируются классы `Process` и `Queue`.

2. Определяется функция `func(q_in, q_out)`, которая получает значение из очереди `q_in`, печатает его, возводит в
   квадрат и отправляет результат в очередь `q_out`.

3. В блоке `if __name__ == '__main__':`:

    * Создаются две очереди `q_in` и `q_out`.
    * Запускаются 4 процесса, каждый из которых вызывает функцию `func` с аргументами `q_in` и `q_out`.
    * В основном процессе отправляются в очередь `q_in` номера итераций от 0 до 3.
    * Печатаются значения, полученные из очереди `q_out`.

<details>

<summary>Код</summary>

```python
from multiprocessing import Process, Queue


def func(q_in, q_out):
    # получаем значение из очереди
    x = q_in.get()
    # печатаем значение, которое получили из очереди
    print('func get: ', x)
    # отправляем в очередь q_out квадрат, полученного значаения
    q_out.put(x ** 2)


if __name__ == '__main__':
    # создаем две очереди
    q_in = Queue()
    q_out = Queue()
    # создаем и запускаем 4 процесса, которые выполняют func с аргументами q_in, q_out
    for x in range(4):
        p = Process(target=func, args=(q_in, q_out))
        p.start()
    # отправляем в очередь q_in номер итерации
    # печатаем значаением, полученное из очереди q_out
    for x in range(4):
        q_in.put(x)
        print('in main recv: ', q_out.get())
```

</details>